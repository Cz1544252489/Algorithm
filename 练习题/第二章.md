# 算法基础
### 2.1-1
（主要使用MATLAB符号）

S1: A=[31 41 59 26 41 58] 判断A(1)和A(2)，由于A(1)<=A(2)，则不改变位置（或称把A(2)放在A(1)后面）;

S2: A=[31 41 59 26 41 58] 判断A(2)和A(3)，由于A(2)<=A(3)，则也不改变位置;

S3: A=[31 41 59 26 41 58] 判断A(3)和A(4)，由于A(3)>A(4)，则交换A(3)和A(4)，即有 A=[31 41 26 59 41 58];

&emsp;&emsp;再判断A(2)和A(3)，由于A(2)>A(3)，则交换A(2)和A(3)，即有 A=[31 26 41 59 41 58];
    
&emsp;&emsp;再判断A(1)和A(2)，由于A(1)>A(2)，则交换A(1)和A(2)，即有 A=[26 31 41 59 41 58];
    
S4: A=[26 31 41 59 41 58] 判断A(4)和A(5)，由于A(4)>A(5)，则交换A(4)和A(5)，即有 A=[26 31 41 41 59 58];

&emsp;&emsp;再判断A(3)和A(4)，由于A(3)<=A(4)，则不改变位置;
    
S5: A=[26 31 41 41 59 58] 判断A(5)和A(6)，由于A(5)>A(6)，则交换A(5)和A(6)，即有 A=[26 31 41 41 58 59];

&emsp;&emsp;再判断A(4)和A(5)，由于A(4)<=A(5)，则不改变位置；
    
### 2.1-2
***MATLAB代码***

```
Vector = [8 2 4 9 3 6];
for j = 2:length(Vector)
    key = Vector(j);
    i = j - 1;
    while(i>0 && Vector(i)<key)
        Vector(i+1) = Vector(i);
        i = i - 1;
    end
    Vector(i+1) = key;
end
disp(Vector);
```

***Python代码***
```
import numpy as np
Vector = np.array([8, 2, 4, 9, 3, 6])
for j in range(1, len(Vector)):
    key = Vector[j]
    i = j -1;
    while i>=0 and Vector[i]<key:
        Vector[i+1] = Vector[i]
        i = i -1
    Vector[i+1] = key
print(Vector)
```

### 2.1-3
***伪代码***

```
SEARCH(A, v)
flag = 0
for i = 1 to A.length
    if A[i] == v
        flag = 1
        break
if flag
    return i
else
    return NIL
```

### 2.1-4
***伪代码***
```
Binary_plus(A,B)
n = A.length
C = zeros(1,n+1)
C[n+1] = (A[n] + B[n]) mod 2
for i = n downto 2
    C[i] = (A[i-1] + B[i-1]) mod 2 + $\lfloor$ (A[i] + B[i])/2 $\rfloor$
C[1] = $\lfloor$ (A[1] + B[1])/2 $\rfloor$
return C
```
